---
title: "Lab#2 - Programming Fundamentals"
author: "Rasmus W. Schm√∏kel"
date: '2022-09-05'
output: html_document
---


### Defining a Function

You can write your own functions in order to make repetitive operations using a single command. Let's start by defining your function "my_function" and the input parameter(s) that the user will feed to the function. Afterwards you will define the operation that you desire to program in the body of the function within curly braces ({}). Finally, you need to assign the result (or output) of your function in the return statement.

```{r, include = FALSE}
my_function <- function(input) {
# perform action and produce output
return(output) # return output value
}
```

Now let's see this process with an example. We are going to define a function `area_of_rectangle` that calculates the [area of a rectangle](https://www.wikihow.com/Calculate-the-Area-of-a-Rectangle)
```{r}
area_of_rectangle <- function(length, width) {
  area <- length * width
  return(area)
}
```

We define `area_of_rectangle` by assigning it to the output of `function`.
The list of argument names are contained within parentheses.
Next, the body of the function, the statements that are executed when it runs, is contained within curly braces (`{}`).
The statements in the body are indented by two spaces, which makes the code easier to read but does not affect how the code operates.

When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function.
Inside the function, we use a return statement to send a result back to whoever asked for it.

 ## Automatic Returns

 In R, it is not necessary to include the return statement.
 R automatically returns whichever variable is on the last line of the body
 of the function. While in the learning phase, we will explicitly define the
 return statement.

Let's try running our function.
Calling our own function is no different from calling any other function:

```{r}

area_of_rectangle(10, 10)
# and you can assign it to an object/variable
area <- area_of_rectangle(10, 50)
area
```

We've successfully called the function that we defined, and we have access to the value that we returned.


Now that we've seen how to calculate the area of a rectangle it is easy to calculate the area of a right triangle. We could write out the formula, but we don't need to.
Instead, we can use the function we have already created:

```{r}
area_of_triangle <- function(length, width) {
  area <- area_of_rectangle(length, width)/2

  return(area)
}
# 
area_of_triangle(10,10)
```

This is our first taste of how larger programs are built: we define basic
operations, then combine them in ever-larger chunks to get the effect we want.
Real-life functions will usually be larger than the ones shown here--typically half a dozen to a few dozen lines--but they shouldn't ever be much longer than that, or the next person who reads it won't be able to understand what's going on.

#Functions
**1) Make a function that prints the string "The result is:"**
```{r}


#Your code here
```

**2) Building on 1, make a function that calculates the mean of vector 'example_vector', and prints the results: "The result is: [result]"**
```{r}

example_vector <- c(1,2,45645,6543,234,989)

#Your code here
```


**3) Construct a function that calculates the area of multiple triangles (from 2 to infinity). (hint: vectors)**
```{r}



#Your code here
```
# Control flow & Iterations

R is a programming language after all, how do we check for conditions or go through iterations?

if/else statements allow you to check for conditions:
```{r}
x <- 4

if (x > 4)
{
  print("larger than four")
} else
{
  print("four or less")
}

```

for loops are fixed length iterations:

```{r}
sequence <- seq(1,10)

for (i in sequence)
{
  print(i+1)
}

```

while loops let you iterate as long as a condition is met:

```{r, eval=F}
i <- 1
while (i<10)
{
  print(i) #Be aware of infinte loops!!!!!!
  i <- i+1
}
```

A often faster and more syntax-friendly implementatin of iterations is the apply-function family. type '?sapply' to read more about it

```{r, eval=F}

sapply(mtcars, mean)

```


**Note:** control flow is very inefficient in R, we will learn faster methods for large datasets later in the course

Your turn: 

**4) Iterate over the numbers from 1 to 50 and print the ones divisible by 7.**
```{r}
#Your code here
```



**5) mtcars is a built-in dataset in R. Print every column name of the dataset using a for loop**
```{r}
#The names of the columns in 'mtcars'
names(mtcars)

#Your code here
```

**6)  Print the type (e.g. character, numeric, logical) of every column in mtcars using sapply**
```{r}

#Your code here
```

**7)  calculate the mean of every column in mtcars using sapply and assign it to a new object Also, assign the corresponding column names to the means in the new object**
```{r}

#Your code here
```